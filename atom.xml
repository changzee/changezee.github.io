<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://changzee.github.io.git</id>
    <title>顶洋小巷</title>
    <updated>2020-11-22T09:03:46.385Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="http://changzee.github.io.git"/>
    <link rel="self" href="http://changzee.github.io.git/atom.xml"/>
    <subtitle>记录一些日常学习笔记与感想～</subtitle>
    <logo>http://changzee.github.io.git/images/avatar.png</logo>
    <icon>http://changzee.github.io.git/favicon.ico</icon>
    <rights>All rights reserved 2020, 顶洋小巷</rights>
    <entry>
        <title type="html"><![CDATA[git标签  ]]></title>
        <id>http://changzee.github.io.git/post/git-biao-qian/</id>
        <link href="http://changzee.github.io.git/post/git-biao-qian/">
        </link>
        <updated>2020-11-22T08:49:30.000Z</updated>
        <content type="html"><![CDATA[<p>WIP   Work in progress, do not merge yet. // 开发中<br>
LGTM Looks good to me. // Riview 完别人的 PR ，没有问题<br>
PTAL Please take a look. // 帮我看下，一般都是请别人 review 自己的 PR<br>
CC Carbon copy // 一般代表抄送别人的意思<br>
RFC  —  request for comments. // 我觉得这个想法很好, 我们来一起讨论下<br>
IIRC  —  if I recall correctly. // 如果我没记错<br>
ACK  —  acknowledgement. // 我确认了或者我接受了,我承认了<br>
NACK/NAK — negative acknowledgement. // 我不同意</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[日常用到的一些开发工具汇总与推荐]]></title>
        <id>http://changzee.github.io.git/post/ri-chang-yong-dao-de-yi-xie-kai-fa-gong-ju-hui-zong-yu-tui-jian/</id>
        <link href="http://changzee.github.io.git/post/ri-chang-yong-dao-de-yi-xie-kai-fa-gong-ju-hui-zong-yu-tui-jian/">
        </link>
        <updated>2020-11-22T08:38:06.000Z</updated>
        <content type="html"><![CDATA[<h2 id="windows-软件">Windows 软件</h2>
<h3 id="包管理工具-scoop">包管理工具 - [Scoop]</h3>
<p><a href="https://scoop.sh/">官网</a></p>
<h2 id="jetbrains全家桶可用学生邮箱申请license">JetBrains全家桶(可用学生邮箱申请License)</h2>
<h3 id="数据库管理工具-datagrip">数据库管理工具 - DataGrip</h3>
<h3 id="php语言开发ide-phpstrom">PHP语言开发IDE - PHPSTROM</h3>
<h3 id="go语言开发ide-golang">Go语言开发IDE - Golang</h3>
<h3 id="c语言开发ide-clion">C语言开发IDE - Clion</h3>
<p><a href="https://www.jetbrains.com/">官网</a></p>
<h3 id="终端管理工具-window-terminal预览版">终端管理工具 - window terminal(预览版)</h3>
<figure data-type="image" tabindex="1"><img src="http://wiki.meiyou.com/download/attachments/41627539/image2019-12-8_13-28-14.png?version=1&amp;modificationDate=1575782894552&amp;api=v2" alt="商业产品技术中心 &gt; 常用开发软件(window篇) &gt; image2019-12-8_13-28-14.png" loading="lazy"></figure>
<p>可在microsoft store上直接安装</p>
<figure data-type="image" tabindex="2"><img src="http://wiki.meiyou.com/download/attachments/41627539/image2019-12-8_13-29-38.png?version=1&amp;modificationDate=1575782978720&amp;api=v2" alt="商业产品技术中心 &gt; 常用开发软件(window篇) &gt; image2019-12-8_13-29-38.png" loading="lazy"></figure>
<h3 id="终端必备神器-oh-my-zsh"><strong>终端必备神器 - Oh my zsh!</strong></h3>
<figure data-type="image" tabindex="3"><img src="https://ohmyz.sh/img/themes/nebirhos.jpg" alt="nebirhos" loading="lazy"></figure>
<pre><code class="language-powershell">sudo apt-get install zsh
sh -c &quot;$(curl -fsSL https://raw.github.com/ohmyzsh/ohmyzsh/master/tools/install.sh)&quot;
</code></pre>
<h3 id="hosts管理工具-switchhosts">Hosts管理工具 - SwitchHosts!</h3>
<figure data-type="image" tabindex="4"><img src="https://raw.githubusercontent.com/oldj/SwitchHosts/master/screenshots/sh_light.png" alt="Capture" loading="lazy"></figure>
<p><a href="https://oldj.github.io/SwitchHosts/">官网</a></p>
<h3 id="压缩-解压缩工具-7zip">压缩 &amp;&amp; 解压缩工具 - 7zip</h3>
<p><a href="https://www.7-zip.org/">官网</a></p>
<pre><code class="language-powershell"># 通过 scoop 安装
scoop install 7zip
</code></pre>
<h3 id="快速搜索工具-everything">快速搜索工具 - Everything</h3>
<p><a href="https://www.voidtools.com/">官网</a></p>
<pre><code class="language-powershell">scoop install everything
</code></pre>
<h3 id="快速启动工具window上的alfred-wox-listary-任选一个">快速启动工具(window上的Alfred）- Wox || Listary （任选一个）</h3>
<figure data-type="image" tabindex="5"><img src="http://wiki.meiyou.com/download/attachments/41627539/image2019-12-8_13-25-43.png?version=1&amp;modificationDate=1575782743412&amp;api=v2" alt="商业产品技术中心 &gt; 常用开发软件(window篇) &gt; image2019-12-8_13-25-43.png" loading="lazy"></figure>
<p><a href="http://www.wox.one/">wox</a> <a href="https://www.listary.com/">listary</a></p>
<pre><code class="language-powershell">scoop install wox
scoop install listary
</code></pre>
<h3 id="编辑工具-vscode-sublime">编辑工具 - VSCode &amp;&amp; sublime</h3>
<p><a href="https://code.visualstudio.com/">vscode</a> <a href="https://www.sublimetext.com/">sublime</a></p>
<pre><code class="language-powershell">scoop install vscode
scoop install sublime-text
</code></pre>
<h3 id="屏幕显示按钮工具-carnac">屏幕显示按钮工具 - carnac</h3>
<p><a href="https://github.com/Code52/carnac">github</a></p>
<pre><code class="language-powershell">scoop install carnac
</code></pre>
<h3 id="markdown-编辑器-typora-mermaid">Markdown 编辑器 - Typora &amp;&amp; mermaid</h3>
<p><a href="https://typora.io/">typora</a> <a href="https://mermaidjs.github.io/">mermaid</a></p>
<pre><code class="language-powershell">scoop install typora
</code></pre>
<h3 id="卸载工具-geek-uninstaller">卸载工具 - Geek uninstaller</h3>
<pre><code class="language-powershell">scoop install geekuninstaller
</code></pre>
<h3 id="视频播放器-mpc-be">视频播放器 - mpc-be</h3>
<pre><code class="language-powrshell">scoop install mpc-be
</code></pre>
<h3 id="视频录制-直播工具-obs-studio">视频录制 / 直播工具 - OBS-studio</h3>
<p><a href="https://obsproject.com/">官网</a></p>
<pre><code class="language-powershell">scoop install obs-studio
</code></pre>
<h3 id="刻录工具-rufus">刻录工具 - Rufus</h3>
<p><a href="http://rufus.ie/">官网</a></p>
<pre><code class="language-powershell">scoop install rufus
</code></pre>
<h3 id="快速预览工具-quicklook">快速预览工具 - QuickLook</h3>
<p>微软应用商店获取 uwp 版本，scoop 可以获取常规版本</p>
<pre><code class="language-powershell">scoop install quicklook
</code></pre>
<h2 id="vscode-插件">VSCode 插件</h2>
<h3 id="uml-工具-plantuml">UML 工具 - plantUML</h3>
<p><a href="http://plantuml.com/">homepage</a></p>
<h3 id="http-client-rest-client">Http Client - REST Client</h3>
<h3 id="json-显示插件-json-viewer-awesome">JSON 显示插件 - JSON Viewer Awesome</h3>
<h3 id="github-目录树-octotree">Github 目录树 - Octotree</h3>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[select-case使用时遇到的问题]]></title>
        <id>http://changzee.github.io.git/post/select-case-shi-yong-shi-yu-dao-de-wen-ti/</id>
        <link href="http://changzee.github.io.git/post/select-case-shi-yong-shi-yu-dao-de-wen-ti/">
        </link>
        <updated>2020-10-22T08:48:01.000Z</updated>
        <content type="html"><![CDATA[<p>上期在写渲染中台需求时碰到了几个挺有意思却挺基础的问题，记录一下防止重蹈覆辙。</p>
<p>需求大概是这样的，我在特定条件下触发会两个周期性定时任务, 其中一个任务在每次结束时会检测某个条件分支，如果成立则使得两个任务都终止。比较常见的思路是同时启用两个协程，两个协程之间采用<code>CPS</code>的方式进行通信。例如下面这样子:</p>
<pre><code class="language-go">cancelCtx, cancel := context.WithCancel(context.Background())

go func() {
  Loop: for {
    select {
      case &lt;-time.NewTicket(5 * time.Minute).C:
     	  // dosomething
      case &lt;-cancelCtx:
      	break Loop // 结束协程
    }
  }
}

go func() {
  Loop: for {
    select {
      case &lt;-time.NewTicket(10 *time.Minute).C:
        // do anothing thing ...
        ...
        
      if condition == true {
        cancel()
        break Loop
      }
    }
  }
}

</code></pre>
<p>但写的时候我觉得两个协程写起来感觉没那么直观，为什么我需要两个协程呢？所以采用了另外一种取巧的方式实现:</p>
<pre><code class="language-go">go func() {
  Loop: for {
    select {
      case &lt;-time.NewTicker(5 * time.Minute).C:
        // do something.
      case &lt;-time.NewTicker(10 * time.Minute).C:
        // do another thing.
        
        ...
      	if condition == true {
        	break Loop
      	}
    }
  }
}
</code></pre>
<p>这时候尴尬就来了，在自测的时候我发现第二个分支永远不会触发。</p>
<p>这种写法问题的根源在于每一次<code>for...select</code>时各个<code>case</code>都会新建一个<code>channel</code>，但我们这时候有多个分支。</p>
<p>第一次<code>for</code>轮训:</p>
<p>分支一新建了一个<code>ticker</code>, 等待5分钟后该分支满足触发条件。</p>
<p>分支二也新建了一个<code>ticker</code>, 等待10分钟后该分支满足触发条件。</p>
<p><code>select</code>一直阻塞等待下属的分支触发，分支一比分支二先触发，选择执行分支一，然后第一次轮训结束。</p>
<p>接下来:</p>
<p>与第一次for轮训一样。</p>
<p>这时候只会执行到周期最短的那个分支。这与我之前的想法不太一致，我以为go编译器会智能地做一些优化，每次轮询到同一个<code>channel</code>实例。解决这个问题的话也挺简单的，在<code>for</code>循环之前先定义好各个分支的<code>channel</code>就行了:</p>
<pre><code class="language-go">tick1:= time.NewTicker(5 * time.Minute)
tick2 := time.NewTicker(10 * time.Second)

defer minTick.Stop()
defer secondTick.Stop()
go func() {
  Loop: for {
    select {
      case &lt;- tick1:
        // do something.
      case &lt;- tick2:
        // do another thing.
        
        ...
      	if condition == true {
        	break Loop
      	}
    }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Golang如何跳出for...select循环]]></title>
        <id>http://changzee.github.io.git/post/golang-ru-he-tiao-chu-forselect-xun-huan/</id>
        <link href="http://changzee.github.io.git/post/golang-ru-he-tiao-chu-forselect-xun-huan/">
        </link>
        <updated>2020-10-21T08:44:35.000Z</updated>
        <content type="html"><![CDATA[<p>在<code>select</code>在<code>for</code>循环体中，无法直接通过<code>break</code>关键字退出执行体，而是需要一些<code>tick</code>。</p>
<p>跟茴字的写法一致，跳出<code>for...select...</code>循环也有多种写法。</p>
<h2 id="使用匿名函数">使用匿名函数</h2>
<pre><code class="language-go">func () {
  for {
    select {
      case &lt;-time.NewTicket(10 *time.Minute).C:
        // do anothing thing ...
        ...

        if condition == true {
          return
        }
    }
  }
}()
</code></pre>
<h2 id="使用break">使用break</h2>
<pre><code class="language-go">Loop: for {
  select {
    case &lt;-time.NewTicket(10 *time.Minute).C:
      // do anothing thing ...
      ...

      if condition == true {
        break Loop
      }
  }
}
</code></pre>
<h2 id="使用goto">使用goto</h2>
<pre><code class="language-go">for {
  select {
    case &lt;-time.NewTicket(10 *time.Minute).C:
      // do anothing thing ...
      ...

      if condition == true {
        goto End
      }
  }
}

End:
	// do something
</code></pre>
<h2 id="使用标记变量">使用标记变量</h2>
<pre><code class="language-go">for condition { // 满足条件则不再执行
  select {
    case &lt;-time.NewTicket(10 *time.Minute).C:
      // do anothing thing ...
      ...

      if condition { // 跳出select
        break
      }
  }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Laravel实践中遇到的一些坑]]></title>
        <id>http://changzee.github.io.git/post/laravel-shi-jian-zhong-yu-dao-de-yi-xie-keng/</id>
        <link href="http://changzee.github.io.git/post/laravel-shi-jian-zhong-yu-dao-de-yi-xie-keng/">
        </link>
        <updated>2020-10-13T08:39:41.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<ol>
<li>
<p><code>mpociot/laravel-apidoc-generator</code>由于注释星号个数问题导致生成的接口文档缺失。正确格式为 <code>/** xxxx */</code>, 开头的星号只能为2个</p>
</li>
<li>
<p><code>mpociot/laravel-apidoc-generator</code>运行文档生成命令时碰到下面的错误:</p>
<pre><code>In SKUserProductController.php line 216:

Unparenthesized `a ? b : c ? d : e` is deprecated. Use either `(a ? b : c) ? d : e` or `a ? b : (c ? d : e)`
</code></pre>
<p>原因是PHP7.4不支持了三元表达式的一些写法，更正对应的代码块或者用低版本的PHP运行。</p>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[golang web项目统一响应风格及错误处理机制]]></title>
        <id>http://changzee.github.io.git/post/golang-web-xiang-mu-tong-yi-xiang-ying-feng-ge-ji-cuo-wu-chu-li-ji-zhi/</id>
        <link href="http://changzee.github.io.git/post/golang-web-xiang-mu-tong-yi-xiang-ying-feng-ge-ji-cuo-wu-chu-li-ji-zhi/">
        </link>
        <updated>2020-09-23T08:35:47.000Z</updated>
        <content type="html"><![CDATA[<!-- more -->
<!-- more -->
<p>这段时间一直在和golang和部门内部开发的go web框架打交道，发现其存在一些些小瑕疵，使用起来跟Gin差距比较明显。比如，由于它缺失了内部缺失了http api返回数据结构规范化及自定义的一些机制，同时对错误处理的方式没有一个比较好用的推荐姿势。所以我在项目应用层写了一两个package来做对应的优化。</p>
<h3 id="更加优雅的输出姿势">更加优雅的输出姿势</h3>
<h4 id="统一输出结构">统一输出结构:</h4>
<pre><code class="language-go">// Standard means standard output struct
type Standard struct {
    Code    int         `json:&quot;code&quot;`              // 业务状态码
    Message string      `json:&quot;message,omitempty&quot;` // 业务信息
    Data    interface{} `json:&quot;data,omitempty&quot;`    // 数据
}
</code></pre>
<p>另外, 特殊输出格式可以采用与Gin一致的H类型:</p>
<pre><code class="language-go">type H map[string]interface{}
</code></pre>
<h4 id="生成对应结构体可以使用以下全局方法">生成对应结构体可以使用以下全局方法:</h4>
<pre><code class="language-go">// JSON 输出规范结构体
func JSON(ctx *web.Context, httpCode int, data *Standard) {
    if response, err := jsoniter.MarshalToString(data); err != nil {
        logger.Errorf(&quot;json解析失败: %+v&quot;, err)
    } else {
        ctx.Response(httpCode, response)
    }
}

// CustomizeJSON 自定义输出json
func CustomizeJSON(ctx *web.Context, httpCode int, h H) {
    if response, err := jsoniter.ConfigFastest.MarshalToString(h); err != nil {
        logger.Errorf(&quot;json解析失败: %+v&quot;, err)
    } else {
        response.Response(httpCode, response)
    }
}

// Success 成功输出
func Success(ctx *web.Context, data ...interface{}) {
    JSON(http.StatusOK, &amp;Standard{Data: data})
}

// String 直接输出
func String(ctx *web.Context, httpCode int, data ...string) {
    message := &quot;&quot;
    if len(data) &gt; 0 {
        message = data[0]
    }

    ctx.Response(httpCode, message)
}
</code></pre>
<h4 id="使用姿势">使用姿势:</h4>
<pre><code class="language-go">// 统一返回格式
func Echo(ctx *web.Context) {
    response.JSON(ctx, http.StatusOK, &amp;response.Standard{
        &quot;words&quot;: &quot;Hello world&quot;
    })
}

// 自定义返回
// Metrics 返回运行状态信息
func Metrics(ctx *web.Context) {
    memStat := runtime.MemStats{}
    runtime.ReadMemStats(&amp;memStat)
    response.CustomizeJSON(ctx, http.StatusOK, response.H{
        &quot;NumCPU&quot;:       runtime.NumCPU(),
        &quot;NumGoroutine&quot;: runtime.NumGoroutine(),
        &quot;QPS&quot;:          middleware.ReqQps.GetQps(),
        &quot;memStat&quot;:      memStat,
    })
}
</code></pre>
<h3 id="统一错误处理机制">统一错误处理机制</h3>
<p>“大道至简”的Go采用的错误处理机制一直饱受争议，其设计理念可以参考社区的博客(https://blog.golang.org/errors-are-values)。 这种机制给很多人的感觉像是回退到了C语言，处理起来对比(try-catch/monad)来说比较丑陋麻烦, 而且err也容易写飞(很多新人直接<code>return errors.New(&quot;这里发生了个小错误&quot;)</code>)。接下来将探讨如何在这种环境下夹缝求生。</p>
<h4 id="针对web请求错误而定义的错误类型">针对WEB请求错误而定义的错误类型</h4>
<p>为了与上面的输出结构统一，定义了以下的错误结构体:</p>
<pre><code class="language-go">// Error 统一错误处理结构
type Error struct {
    HttpCode int    `json:&quot;http_status&quot;` // 对应http状态码
    Code     int    `json:&quot;code&quot;`        // 错误返回码
    Message  string `json:&quot;message&quot;`     // 错误信息
}

// Error 获取错误信息
func (e Error) Error() string {
    return e.Message
}

// GetErrCode 获取业务错误码
func (e Error) GetErrCode() int {
    return e.Code
}

// GetHttpCode 获取http码
func (e Error) GetHttpCode() int {
    return e.HttpCode
}

// New 新建错误
func New(code int, message string, httpCode int) Error {
    return Error{httpCode, code, message}
}
</code></pre>
<p>同时，在response层新增了一个方法,用于统一返回错误信息:</p>
<pre><code class="language-go">// Error 返回错误结构体，后面有详细的实现
func Error(ctx *web.Context, err error) {
   var target errors.Error
   JSON(target.GetHttpCode(), &amp;Standard{target.GetErrCode(), target.Error(), })
}
</code></pre>
<p>这样，在控制器层，一旦接收到err我们想返回的话，直接:</p>
<pre><code class="language-go">if err != nil {
	 response.Error(err)
}
</code></pre>
<h4 id="错误值统一定义">错误值统一定义</h4>
<p>错误值可以是满足语言定义的error 接口的任何类型。程序可以使用类型断言(type assertion)或类型开关(type switch)来判断错误值是否可被视为特定的错误类型。但是这样的话你需要为每种错误定义对应的类型，不好做处理。如:</p>
<pre><code class="language-go">type NotFoundError struct {
    Name string
}

func (e *NotFoundError) Error() string { return e.Name + &quot;: not found&quot; }

if e, ok := err.(*NotFoundError); ok {
    // e.Name wasn't found
}
</code></pre>
<p>直接定义对应全局错误，然后直接通过比较来判断是否发生对应的错误会更加方便些:</p>
<pre><code class="language-go">var ErrNotFound = errors.New(&quot;not found&quot;)

if err == ErrNotFound {
    // something wasn't found
}
</code></pre>
<p>所以我在应用层定义了一个global文件，用于定义全局错误，同时也方便查看还有生成文档:</p>
<pre><code class="language-go">var (
    ValidationError   = New(400, &quot;输入参数有误&quot;, http.StatusBadRequest)
    ForbiddenError    = New(403, &quot;用户未登录&quot;, http.StatusForbidden)
    NotFoundError     = New(404, &quot;找不到请求的资源&quot;, http.StatusNotFound)

    VirtualNoLoginError             = New(110000, &quot;请先登陆哦&quot;, http.StatusOK)
    OrderNotExistError              = New(120000, &quot;订单不存在&quot;, http.StatusOK)
    OrderSkuNotExistError           = New(120002, &quot;订单Sku不存在&quot;, http.StatusOK)
    OrderConfirmReceiptError        = New(120003, &quot;当前订单中有退货中的商品，完成退款后才能确认收货哦~&quot;, http.StatusOK)
    CartPublishSkuExistError        = New(124000, &quot;购物车中已经有相同商品，无法修改规格哦~&quot;, http.StatusOK)
)
</code></pre>
<p>这样的话，如果说上层想知道下层发生了什么错误可以直接做比较:</p>
<pre><code class="language-go">if err == ValidationError {
	// logger.Error(“验证错误: %+v”, err)
} else if err == OrderNotExistError {
	// 一些业务处理
}
</code></pre>
<h4 id="接口返回错误">接口返回错误</h4>
<p>如何返回错误在go中是一个比较麻烦的事情，特别要区分是业务错误和系统错误。我之前的想法是函数返回两个err, 一个用于标志业务错误，另一个用于标志系统错误, 后面想想这种方式有些丑陋。后来基于标准库1.13版本改写了下<code>response.Error</code>方法，统一了两者:</p>
<pre><code class="language-go">// Error 返回错误结构体...
func Error(err error) {
    var target errors.Error

    // 如果错误为业务错误类型则进行特殊格式化处理
    if errors.As(err, &amp;target) {        
        JSON(target.GetHttpCode(), &amp;Standard{target.GetErrCode(), target.Error(), })
    } else {
        logger.Errorf(&quot;响应异常: %+v&quot;, err)
        
        // 测试环境与本地开发环境直接打印错误，方便debug
        if Env == DEV || Env == TEST {
            String(http.StatusInternalServerError, fmt.Sprintf(&quot;系统错误: %+v&quot;, err))
        } else {
            String(http.StatusInternalServerError, http.StatusText(http.StatusInternalServerError))
        }
    }
}

</code></pre>
<p>同时对系统错误做了下特殊处理，在测试与开发环境下抛出对应的调用栈，只需要在抛出错误的时候使用:</p>
<pre><code class="language-go">import errors2 &quot;github.com/pkg/errors&quot;

if err != nil {
    // 为错误包一层调用栈信息，这样response.Error能够直接打印
	return errors2.WithStack(errors.ServiceInnerError)
}
</code></pre>
<h4 id="携带数据的错误值">携带数据的错误值</h4>
<p>如何为错误值包裹一层数据是件比较难的事，因为如果直接修改全局错误的话会导致在上层不能比对特定的错误，对此借鉴了标准库的一些写法:</p>
<pre><code class="language-go">// withData is a error with some specific data.
type withData struct {
    error
    data interface{}
}

// Data function gets the Error data of withData
func (w *withData) Data() interface{} {
    return w.data
}

// WrapData function wraps error with data.
func WithData(err error, data interface{}) error {
    if err == nil {
        return nil
    }
    return &amp;withData{err, data}
}

// Unwrap provides compatibility for Go 1.13 error chains.
func (w *withData) Unwrap() error { return w.error }
</code></pre>
<p>这样想返回错误数据的话只需要:</p>
<pre><code class="language-go">if err != nil {
	return errors.WithData(errors.OrderNotExistError, map[string]interface{}{
		&quot;order_id&quot;: orderId // 顺便返回对应的订单ID
	})
}
</code></pre>
<p>最后需要修改下<code>response.Error</code>方法:</p>
<pre><code class="language-go">// Error 返回错误结构体.
func Error(err error) meetyou.HttpCodeResponse {
    var target errors.Error

    // 如果错误为业务错误类型则进行特殊格式化处理
    if errors.As(err, &amp;target) {
        var errData interface{} = nil
        if tmp, ok := err.(interface{Data() interface{}}); ok {
            errData = tmp.Data()
        }
        return JSON(target.GetHttpCode(), &amp;Standard{target.GetErrCode(), target.Error(), errData})
    } else {
        logger.Errorf(&quot;响应异常: %+v&quot;, err)
        if meetyou.Env == meetyou.DEV || meetyou.Env == meetyou.TEST {
            return String(http.StatusInternalServerError, fmt.Sprintf(&quot;系统错误: %+v&quot;, err))
        } else {
            return String(http.StatusInternalServerError, http.StatusText(http.StatusInternalServerError))
        }
    }
}

</code></pre>
<h3 id="其他">其他</h3>
<h4 id="发生系统错误的怎么办">发生系统错误的怎么办:</h4>
<ol>
<li>
<p>对于异常, 直接panic，应用层使用recover恢复，方便排查错误</p>
</li>
<li>
<p>日志记录错误，非业务错误需层层进行记录，方便排查问题</p>
<pre><code class="language-go">import errors2 &quot;github.com/pkg/errors&quot;

if err != nil {
     err = errors2.WithStack(err)
	logger.Errorf(&quot;xxx发生错误: %+v&quot;, err)
     // 为错误包一层调用栈信息，这样response.Error能够直接打印
	return err
}
</code></pre>
</li>
</ol>
]]></content>
    </entry>
</feed>